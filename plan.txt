TODO:

Enforce Commit Barriers and Ordering: Implement A13 commit barriers to separate ingestion from commitment, ensuring micro-steps are fenced and no mutations occur during contemplation. Add explicit markers for budget ladders and trace cache limits.
Budget and Capacity Caps: Introduce hard caps (e.g., N_MAX, K_MAX, PENDING_MAX) with deterministic eviction policies, preventing silent growth and aligning with A0.BUDGET. Incorporate problem-bound modes for fovea selection under compute pressure.
Scan-Proof Index Maintenance: Replace full rebuilds in incumbents with O(1) deletes via per-unit bucket lists, and limit maintenance to BUCKET_MAINT_MAX operations per tick.
Deferred Validation and Stats Updates: Restructure the prediction store as a ring with footprint-local constraints, deferring stats updates to validation steps only, per A4.5.
Diagnostic Enhancements: Update logging to include v5.02/3 markers (e.g., block stats per A16.5.6, purge/index health), ensuring diagnostics have no control influence (A17.3).
Remove Legacy Elements: Eliminate full-state modes, replays, and wallclock-based relaxations, converting to online, outcome-vetted updates and physics-only environments.
Determinism and Lag Discipline: Use lagged predicates for gates (A0.5, A14.1) and ensure no cross-tick smuggling in signatures.


For consideration only:

Several components can be substituted with existing libraries or tools, provided replacements preserve sublinear access, no scans, determinism, and budget bounds as per the v5.02/3 axioms (e.g., A4.3′, A16.6′). No modifications to axioms are required, as these focus on interfaces and contracts:

Locality-Sensitive Hashing (LSH) for Retrieval: The SimHash-based banded index can be replicated using datasketch (MinHashLSH), which supports fixed-capacity buckets and Hamming distance queries. This maintains scan-proof retrieval by probing only relevant bands, with candidates capped via heap operations. Integration: Replace MultiSimHashBands with datasketch.MinHashLSH while keeping 64-bit signatures and block-scoping.
State Estimation and Completion: The unified completion operator (clamping sparse cues into priors) can use scipy.sparse for efficient sparse matrix operations or pandas for imputation-like handling of missing values. For Gaussian experts, scipy.stats provides diagonal covariance computations without violating persistence rules.
Prediction with Experts: The DAG-organized experts can leverage networkx for graph management (parents/children edges) and torch (available in the environment) for masked linear modules, ensuring fusion remains precision-weighted and bounded by K_MAX.
Grid World Simulation: The environment in test.py (20x20 grid with moving shapes) can be simulated using pygame for rendering or numpy for array-based updates, preserving occlusion masks and tick decoupling.
Visualization and UI: The rich terminal display can be replicated with matplotlib for grid plotting (e.g., imshow for env/pred/diff) or rich itself if integrated, without affecting decision paths.
Persistence and Serialization: NPZ state saving uses numpy.savez; this can be augmented with joblib for efficient dumping of dataclasses, ensuring no serialization of trace caches (A16.8.4).


